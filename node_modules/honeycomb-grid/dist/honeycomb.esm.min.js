"undefined"!=typeof globalThis?globalThis:"undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self&&self;var t=function(t,n){return t(n={exports:{}},n.exports),n.exports}((function(t,n){
/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */
t.exports=function(){var t={},n="Array Object String Date RegExp Function Boolean Number Null Undefined".split(" ");function e(){return Object.prototype.toString.call(this).slice(8,-1)}for(var r=n.length;r--;)t["is"+n[r]]=function(t){return function(n){return e.call(n)===t}}(n[r]);return t}()})),n=t.isObject,e=t.isNumber,r=t.isArray,i=t.isString;function o(t,n){return n+t*(1&n)>>1}function s(t,n){return(t%n+n)%n}function u(t,n){if(!/^(N|S)?(E|W)?$/i.test(t))throw new Error("Invalid compass direction: ".concat(t,". Choose from E, SE, S, SW, W, NW, N or NE."));if(n=n.toLowerCase(),t=t.toUpperCase(),"pointy"===n&&["N","S"].includes(t))throw new Error("Direction ".concat(t," is ambiguous for pointy hexes. Did you mean ").concat(t,"E or ").concat(t,"W?"));if("flat"===n&&["E","W"].includes(t))throw new Error("Direction ".concat(t," is ambiguous for flat hexes. Did you mean N").concat(t," or S").concat(t,"?"));return{pointy:{E:0,SE:1,SW:2,W:3,NW:4,NE:5},flat:{SE:0,S:1,SW:2,NW:3,N:4,NE:5}}[n][t]}function c(t,n){return e(t)||e(n)?e(t)?e(n)||(n=t):t=n:t=n=0,{x:t,y:n}}const a=[{q:1,r:0,s:-1},{q:0,r:1,s:-1},{q:-1,r:1,s:0},{q:-1,r:0,s:1},{q:0,r:-1,s:1},{q:1,r:-1,s:0}],h=[{q:2,r:-1,s:-1},{q:1,r:1,s:-2},{q:-1,r:2,s:-1},{q:-2,r:1,s:1},{q:-1,r:-1,s:2},{q:1,r:-2,s:1}],l={q:1e-6,r:1e-6,s:-2e-6};function f(t){return e(t)?this[t]:this[this.indexOf(t)]}function d(t){let{isValidHex:n}=t;return function(t,r){if(!n(r))return this;const i=e(t)?t:this.indexOf(t);return i<0?this.push(r):this[i]=r,this}}function x(t,n){const e=t.distance(n),r=1/Math.max(e,1);let i=[];for(let o=0;o<=e;o++){const e=t.nudge().lerp(n.nudge(),r*o).round();i.push(this.get(e))}return i}function g(t){let{isValidHex:n}=t;return function(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,r=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(!n(t))throw new Error("Invalid center hex: ".concat(t,"."));if(!this.get(t))throw new Error("Center hex with coordinates ".concat(t," not present in grid."));let i=[];for(let n=-e;n<=e;n++)for(let o=Math.max(-e,-n-e);o<=Math.min(e,-n+e);o++){const e=this.get(t.cubeToCartesian({q:t.q+n,r:t.r+o}));t.equals(e)&&!r||i.push(e)}return i.filter(Boolean)}}function y(t){let{isValidHex:n,signedModulo:e,compassToNumberDirection:r}=t;return function(t){let o=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"all",s=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!n(t))throw new Error("Invalid hex: ".concat(t,"."));const u=s?h:a;return"all"===o&&(o=[0,1,2,3,4,5]),[].concat(o).map(n=>{i(n)&&(n=r(n,t.orientation)),(n<0||n>5)&&(n=e(n,6));const{q:o,r:s}=u[n];return this.get(t.cubeToCartesian({q:t.q+o,r:t.r+s}))})}}function p(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:e}=this[0].isPointy()?[...this].sort((t,n)=>n.s-t.s||t.q-n.q):[...this].sort((t,n)=>t.q-n.q);return e.toPoint().x-t.toPoint().x+this[0].width()}function b(){if(0===this.length)return 0;const{0:t,length:n,[n-1]:e}=this[0].isPointy()?[...this].sort((t,n)=>t.r-n.r):[...this].sort((t,n)=>n.s-t.s||t.r-n.r);return e.toPoint().y-t.toPoint().y+this[0].height()}function q(t){let{Hex:n}=t;return function(t,e){return n().fromPoint(t,e)}}function P(t){let{Grid:n,Hex:e}=t;return function(t){let{width:r,height:i,start:o,direction:s=1,onCreate:u=(()=>{})}=t;o=e(o);const[c,a,h]={1:["q","r","s"],3:["r","s","q"],5:["s","q","r"]}[s],l=new n;l.width=r,l.height=i,l.start=o,l.direction=s;for(let t=0;t<r;t++)for(let n=0;n<i;n++){const r=e({[c]:t+o[c],[a]:n+o[a],[h]:-t-n+o[h]});u(r,l),l.push(r)}return l}}function w(t){let{Grid:n,Hex:e}=t;return function(t){let{size:r,start:i,direction:o=1,onCreate:s=(()=>{})}=t;i=e(i);const u={1:{rStart:()=>0,rEnd:t=>r-t},5:{rStart:t=>r-t,rEnd:()=>r+1}},{rStart:c,rEnd:a}=u[o],h=new n;h.size=r,h.start=i,h.direction=o;for(let t=0;t<r;t++)for(let n=c(t);n<a(t);n++){const r=e({q:t+i.q,r:n+i.r,s:-t-n+i.s});s(r,h),h.push(r)}return h}}function m(t){let{Grid:n,Hex:e}=t;return function(t){let{radius:r,center:i,onCreate:o=(()=>{})}=t;i=e(i);const s=new n;s.radius=r,s.center=i;for(let t=-r;t<=r;t++){const n=Math.max(-r,-t-r),u=Math.min(r,-t+r);for(let r=n;r<=u;r++){const n=e({q:t+i.q,r:r+i.r,s:-t-r+i.s});o(n,s),s.push(n)}}return s}}function H(t){let{Grid:n,Hex:e,compassToNumberDirection:r,signedModulo:s}=t;return function(t){let{width:u,height:c,start:a,direction:h=(e().isPointy()?0:1),onCreate:l=(()=>{})}=t;a=e(a),i(h)&&(h=r(h,a.orientation)),(h<0||h>5)&&(h=s(h,6));const[f,d,x]=[["q","r","s"],["r","q","s"],["r","s","q"],["s","r","q"],["s","q","r"],["q","s","r"]][h],[g,y]=a.isPointy()?[u,c]:[c,u],p=new n;p.width=u,p.height=c,p.start=a,p.direction=h;for(let t=0;t<y;t++){const n=o(a.offset,t);for(let r=-n;r<g-n;r++){const n=e({[f]:r+a[f],[d]:t+a[d],[x]:-r-t+a[x]});l(n,p),p.push(n)}}return p}}function O(t){let{Grid:n,Hex:e}=t;return function(t){let{radius:r,center:i,onCreate:o=(()=>{})}=t;i=e(i);const s=new n;s.radius=r,s.center=i;const{q:u,r:c,s:h}=i;let l=e({q:u,r:c-r,s:h+r});for(let t=0;t<6;t++)for(let n=0;n<r;n++){o(l,s),s.push(l);const{q:n,r:r,s:i}=a[t];l=e({q:l.q+n,r:l.r+r,s:l.s+i})}return s}}function v(t){let{Grid:n,Hex:e}=t;return function(t){let{radius:r,center:i,onCreate:o=(()=>{})}=t;i=e(i);let s=new n;o(i,s),s.push(i);for(let t=1;t<=r;t++)s=s.concat(this.ring({radius:t,center:i,onCreate:o}));return s.radius=r,s.center=i,s}}function j(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x+r,this.y+e)}}function M(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x-r,this.y-e)}}function E(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x*r,this.y*e)}}function C(t){let{Point:n}=t;return function(t,e){let r;return({x:r,y:e}=n(t,e)),n(this.x/r,this.y/e)}}function N(t){let{ensureXY:i}=t;const o={add:j({Point:s}),subtract:M({Point:s}),multiply:E({Point:s}),divide:C({Point:s})};function s(t,s){let u;return u=e(t)?i(t,s):r(t)?i(...t):n(t)?i(t.x,t.y):i(0),Object.assign(Object.create(o),u)}return s}const S=N({ensureXY:c});class R extends Array{static isValidHex(t){return!0===(t||{}).__isHoneycombHex}fill(){throw new TypeError("Grid.prototype.fill is not implemented")}includes(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;return!!(this.indexOf(t,n)+1)}indexOf(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const{length:e}=this;let r=Number(n);for(t=S(t),r=Math.max(r>=0?r:e+r,0);r<e;r++)if(this[r].equals(t))return r;return-1}lastIndexOf(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.length-1;const{length:e}=this;let r=Number(n);for(t=S(t),r=r>=0?Math.min(r,e-1):e+r;r>=0;r--)if(this[r].equals(t))return r;return-1}push(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];return super.push(...n.filter(R.isValidHex))}splice(t,n){if(null==n)return super.splice(t);for(var e=arguments.length,r=new Array(e>2?e-2:0),i=2;i<e;i++)r[i-2]=arguments[i];return super.splice(t,n,...r.filter(R.isValidHex))}unshift(){for(var t=arguments.length,n=new Array(t),e=0;e<t;e++)n[e]=arguments[e];return super.unshift(...n.filter(R.isValidHex))}}function T(t,n,e){return n in t?Object.defineProperty(t,n,{value:e,enumerable:!0,configurable:!0,writable:!0}):t[n]=e,t}function G(t,n){var e=Object.keys(t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(t);n&&(r=r.filter((function(n){return Object.getOwnPropertyDescriptor(t,n).enumerable}))),e.push.apply(e,r)}return e}function D(t){for(var n=1;n<arguments.length;n++){var e=null!=arguments[n]?arguments[n]:{};n%2?G(Object(e),!0).forEach((function(n){T(t,n,e[n])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(e)):G(Object(e)).forEach((function(n){Object.defineProperty(t,n,Object.getOwnPropertyDescriptor(e,n))}))}return t}function z(t,n){if(null==t)return{};var e,r,i=function(t,n){if(null==t)return{};var e,r,i={},o=Object.keys(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||(i[e]=t[e]);return i}(t,n);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(t);for(r=0;r<o.length;r++)e=o[r],n.indexOf(e)>=0||Object.prototype.propertyIsEnumerable.call(t,e)&&(i[e]=t[e])}return i}function V(t){let{Hex:n}=t;return function(){return Object.assign(this,n(...arguments))}}function W(){return{x:this.x,y:this.y}}function A(){return{q:this.q,r:this.r,s:this.s}}function I(t){let n,e,{q:r,r:i}=t;return this.isPointy()?(n=r+o(this.offset,i),e=i):(n=r,e=i+o(this.offset,r)),{x:n,y:e}}function X(t){let{Point:n}=t;return function(t,e){let r,i,s;return({x:r,y:e}=n(t,e)),this.isPointy()?(i=r-o(this.offset,e),s=e):(i=r,s=e-o(this.offset,r)),{q:i,r:s,s:-i-s}}}function Y(){return"pointy"===this.orientation.toLowerCase()}function B(){return"flat"===this.orientation.toLowerCase()}function _(){const{xRadius:t}=this.size;return this.isPointy()?t*Math.sqrt(3):2*t}function L(){const{yRadius:t}=this.size;return this.isPointy()?2*t:t*Math.sqrt(3)}function k(t){let{Point:n}=t;return function(){const t=this.width(),e=this.height(),{x:r,y:i}=this.origin;return this.isPointy()?[n(t-r,.25*e-i),n(t-r,.75*e-i),n(.5*t-r,e-i),n(0-r,.75*e-i),n(0-r,.25*e-i),n(.5*t-r,0-i)]:[n(t-r,.5*e-i),n(.75*t-r,e-i),n(.25*t-r,e-i),n(0-r,.5*e-i),n(.25*t-r,0-i),n(.75*t-r,0-i)]}}function F(t){let{Point:n}=t;return function(){const{x:t,y:e}=this.origin;return n(this.width()/2-t,this.height()/2-e)}}function U(t){let{Point:n}=t;return function(){const{q:t,r:e,size:r}=this,{xRadius:i,yRadius:o}=r;let s,u;return this.isPointy()?(s=i*Math.sqrt(3)*(t+e/2),u=3*o/2*e):(s=3*i/2*t,u=o*Math.sqrt(3)*(e+t/2)),n(s,u)}}function J(t){let{Point:n,Hex:e}=t;return function(t,r){const{xRadius:i,yRadius:o}=this.size;let s,u,c;return({x:s,y:r}=n(t,r).subtract(this.center())),this.isPointy()?(u=Math.sqrt(3)*s/(3*i)-r/(3*o),c=2/3*(r/o)):(u=2/3*(s/i),c=Math.sqrt(3)*r/(3*o)-s/(3*i)),e({q:u,r:c,s:-u-c}).round()}}function $(t){let{Hex:n,Point:e}=t;return function(t){const{x:r,y:i}=e(t);return n(this.x+r,this.y+i,D({},this))}}function K(t){let{Hex:n,Point:e}=t;return function(t){const{x:r,y:i}=e(t);return n(this.x-r,this.y-i,D({},this))}}function Q(t){let{Point:n}=t;return function(t){if(null!=t&&(r(t)||e(t.x)&&e(t.y))){const{x:e,y:r}=n(t);return this.x===e&&this.y===r}return!1}}function Z(t){return Math.max(Math.abs(this.q-t.q),Math.abs(this.r-t.r),Math.abs(this.s-t.s))}function tt(t){let{Hex:n}=t;return function(){let{q:t,r:e,s:r}=this,i=Math.round(t),o=Math.round(e),s=Math.round(r);const u=Math.abs(t-i),c=Math.abs(e-o),a=Math.abs(r-s);return u>c&&u>a?i=-o-s:c>a?o=-i-s:s=-i-o,n(D({},this,{q:i,r:o,s:s}))}}function nt(t){let{Hex:n}=t;return function(t,e){const r=this.q*(1-e)+t.q*e,i=this.r*(1-e)+t.r*e;return n(D({},this,{q:r,r:i,s:-r-i}))}}function et(t){let{Hex:n}=t;return function(){const{q:t,r:e,s:r}=l;return n(D({},this,{q:this.q+t,r:this.r+e,s:this.s+r}))}}function rt(){return"".concat(this.x,",").concat(this.y)}const it={thirdCoordinate:function(t,n){return-t-n}};const ot=N({ensureXY:c}),st=function(t){let{ensureXY:i,normalizeRadiuses:o,Point:s}=t;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};const u=X({Point:s}),c={__isHoneycombHex:!0,orientation:"pointy",origin:0,size:{xRadius:1,yRadius:1},offset:-1,get q(){return this.cartesianToCube(this).q},get r(){return this.cartesianToCube(this).r},get s(){return this.cartesianToCube(this).s},add:$({Hex:h,Point:s}),cartesian:W,cartesianToCube:u,center:F({Point:s}),coordinates:W,corners:k({Point:s}),cube:A,cubeToCartesian:I,distance:Z,equals:Q({Point:s}),fromPoint:J({Point:s,Hex:h}),height:L,isFlat:B,isPointy:Y,lerp:nt({Hex:h}),nudge:et({Hex:h}),round:tt({Hex:h}),set:V({Hex:h}),subtract:K({Hex:h,Point:s}),toCartesian:I,toCube:u,toPoint:U({Point:s}),toString:rt,width:_},a=Object.assign(c,t);function h(t,o){let s,u=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(n(t)){let{q:n,r:r,s:i}=t,c=z(t,["q","r","s"]);if(e(n)||e(r)||e(i)){const t=n+r+i;if(Number.isNaN(t)||t>1e-12)throw new Error("Cube coordinates must have a sum of 0. q: ".concat(n,", r: ").concat(r,", s: ").concat(i,", sum: ").concat(n+r+i,"."));({x:s,y:o}=a.cubeToCartesian({q:n,r:r,s:i}))}else({x:s,y:o}=t);u=c}else r(t)?([s,o]=t,u={}):s=t;return Object.assign(Object.create(a),Object.assign(u,i(s,o)))}return a.size=o(a.size,a.isPointy()),a.origin=s(a.origin),Object.assign(h,it,{toJSON:()=>t}),h}}({ensureXY:c,normalizeRadiuses:function(t,r){if(n(t)){if(e(t.xRadius)&&e(t.yRadius))return t;const{width:n,height:i}=t;if(e(n)&&e(i))return r?{xRadius:n/Math.sqrt(3),yRadius:i/2}:{xRadius:n/2,yRadius:i/Math.sqrt(3)}}if(e(t))return{xRadius:t,yRadius:t};throw new Error("Invalid size: ".concat(t,". Set it as a number or as an object containing width and height."))},Point:ot}),ut=function(t){let{extendHex:n,Grid:i,Point:o}=t;const{isValidHex:c}=i;return function(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:n();function a(){for(var n=arguments.length,o=new Array(n),s=0;s<n;s++)o[s]=arguments[s];return o=o.filter(Boolean),r(o[0])&&(0===o[0].length||o[0].some(t=>!e(t)))&&(o=o[0]),new i(...o.map(n=>t(n)))}return Object.assign(a,{Hex:t,isValidHex:c,pointToHex:q({Point:o,Hex:t}),parallelogram:P({Grid:i,Hex:t}),triangle:w({Grid:i,Hex:t}),hexagon:m({Grid:i,Hex:t}),rectangle:H({Grid:i,Hex:t,compassToNumberDirection:u,signedModulo:s}),ring:O({Grid:i,Hex:t}),spiral:v({Grid:i,Hex:t})}),Object.assign(i.prototype,{get:f,hexesBetween:x,hexesInRange:g({isValidHex:c}),neighborsOf:y({isValidHex:c,signedModulo:s,compassToNumberDirection:u}),pointHeight:b,pointWidth:p,set:d({isValidHex:c})}),a}}({extendHex:st,Grid:R,Point:ot});export{ot as Point,ut as defineGrid,st as extendHex};
//# sourceMappingURL=honeycomb.esm.min.js.map
