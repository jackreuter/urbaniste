{"version":3,"file":"honeycomb.esm.min.js","sources":["../node_modules/axis.js/dist/axis.js","../src/utils.js","../src/hex/constants.js","../src/grid/prototype.js","../src/grid/statics.js","../src/point/prototype.js","../src/point/index.js","../src/grid/class.js","../src/hex/prototype.js","../src/hex/index.js","../src/hex/statics.js","../src/honeycomb.js","../src/grid/index.js"],"sourcesContent":["/*! axis.js v1.2.1 | (c) 2016 @toddmotto | https://github.com/toddmotto/axis */\n(function (root, factory) {\n  if (typeof define === 'function' && define.amd) {\n    define([], factory);\n  } else if (typeof exports === 'object') {\n    module.exports = factory();\n  } else {\n    root.axis = factory();\n  }\n}(this, function () {\n\n  'use strict';\n\n  var axis = {};\n\n  var types = 'Array Object String Date RegExp Function Boolean Number Null Undefined'.split(' ');\n\n  function type() {\n    return Object.prototype.toString.call(this).slice(8, -1);\n  }\n\n  for (var i = types.length; i--;) {\n    axis['is' + types[i]] = (function (self) {\n      return function (elem) {\n        return type.call(elem) === self;\n      };\n    })(types[i]);\n  }\n\n  return axis;\n\n}));\n","import { isNumber, isObject } from 'axis.js'\n\n/**\n * @private\n *\n * @param   {number} offset     The amount to offset (usually -1 or +1).\n * @param   {number} distance   The distance from 0 in a dimension (x, y or q, r).\n *\n * @returns {number}            The amount to offset in the dimension opposite of the passed `distance`.\n */\nexport function offsetFromZero(offset, distance) {\n  return (distance + offset * (distance & 1)) >> 1\n}\n\n/**\n * @private\n *\n * @param   {number} dividend   The amount to get the remainder from after division.\n * @param   {number} divisor    The amount to divide by.\n *\n * @returns {number}            `dividend % divisor`, except negative dividends \"count back from 0\".\n */\nexport function signedModulo(dividend, divisor) {\n  return ((dividend % divisor) + divisor) % divisor\n}\n\n/**\n * @private\n *\n * @param   {string} value              A cardinal/ordinal compass point.\n * @param   {(pointy|flat)} orientation A hex orientation.\n *\n * @returns {(0|1|2|3|4|5)}             The number direction in the range 0..5.\n */\nexport function compassToNumberDirection(value, orientation) {\n  if (!/^(N|S)?(E|W)?$/i.test(value)) {\n    throw new Error(`Invalid compass direction: ${value}. Choose from E, SE, S, SW, W, NW, N or NE.`)\n  }\n\n  orientation = orientation.toLowerCase()\n  value = value.toUpperCase()\n\n  if (orientation === 'pointy' && ['N', 'S'].includes(value)) {\n    throw new Error(`Direction ${value} is ambiguous for pointy hexes. Did you mean ${value}E or ${value}W?`)\n  }\n  if (orientation === 'flat' && ['E', 'W'].includes(value)) {\n    throw new Error(`Direction ${value} is ambiguous for flat hexes. Did you mean N${value} or S${value}?`)\n  }\n\n  /**\n   * There's an (approximate) compass direction for each side of a hex. The right side of a pointy hex has the east (`'E'`) compass direction.\n   * The bottom right side the southeast (`'SE'`) direction, etc. This also means that pointy hexes don't have a north and south compass direction\n   * and flat hexes don't have a west and east compass direction.\n   *\n   * Number directions map to a side of a hex. A pointy hex's right side is `0`, its bottom right side `1`, its bottom left side `2`, etc.\n   * Number directions of flat hexes start at their bottom right side (`0`), their bottom side is `1`, etc.\n   *\n   * @typedef {string} COMPASS_DIRECTION\n   *\n   * @readonly\n   * @enum {COMPASS_DIRECTION}\n   *\n   * @property {COMPASS_DIRECTION} E  → east\n   * @property {COMPASS_DIRECTION} SE ↘ southeast\n   * @property {COMPASS_DIRECTION} S  ↓ south\n   * @property {COMPASS_DIRECTION} SW ↙ southwest\n   * @property {COMPASS_DIRECTION} W  ← west\n   * @property {COMPASS_DIRECTION} NW ↖ northwest\n   * @property {COMPASS_DIRECTION} N  ↑ north\n   * @property {COMPASS_DIRECTION} NE ↗ northeast\n   */\n  return {\n    pointy: { E: 0, SE: 1, SW: 2, W: 3, NW: 4, NE: 5 },\n    flat: { SE: 0, S: 1, SW: 2, NW: 3, N: 4, NE: 5 },\n  }[orientation][value]\n}\n\nexport function ensureXY(x, y) {\n  if (!isNumber(x) && !isNumber(y)) {\n    x = y = 0\n  } else if (!isNumber(x)) {\n    x = y\n  } else if (!isNumber(y)) {\n    y = x\n  }\n\n  return { x, y }\n}\n\nexport function normalizeRadiuses(size, isPointy) {\n  if (isObject(size)) {\n    if (isNumber(size.xRadius) && isNumber(size.yRadius)) {\n      return size\n    }\n\n    const { width, height } = size\n    if (isNumber(width) && isNumber(height)) {\n      return isPointy\n        ? { xRadius: width / Math.sqrt(3), yRadius: height / 2 }\n        : { xRadius: width / 2, yRadius: height / Math.sqrt(3) }\n    }\n  }\n\n  if (isNumber(size)) {\n    return { xRadius: size, yRadius: size }\n  }\n\n  throw new Error(`Invalid size: ${size}. Set it as a number or as an object containing width and height.`)\n}\n","/**\n * How rows/columns of hexes are placed relative to each other.\n *\n * An even offset:\n * * places **even rows** of **pointy hexes** half a hex right of the odd rows;\n * * places **even columns** of **flat hexes** half a hex down of the odd rows;\n *\n * An odd offset:\n * * places **odd rows** of **pointy hexes** half a hex right of the even rows;\n * * places **odd columns** of **flat hexes** half a hex down of the even rows;\n *\n * @name OFFSET\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com}\n *\n * @readonly\n * @enum {number}\n *\n * @property {number} even  +1\n * @property {number} odd   -1\n */\n\nexport const DIRECTION_COORDINATES = [\n  { q: 1, r: 0, s: -1 },\n  { q: 0, r: 1, s: -1 },\n  { q: -1, r: 1, s: 0 },\n  { q: -1, r: 0, s: 1 },\n  { q: 0, r: -1, s: 1 },\n  { q: 1, r: -1, s: 0 },\n]\n\nexport const DIAGONAL_DIRECTION_COORDINATES = [\n  { q: 2, r: -1, s: -1 },\n  { q: 1, r: 1, s: -2 },\n  { q: -1, r: 2, s: -1 },\n  { q: -2, r: 1, s: 1 },\n  { q: -1, r: -1, s: 2 },\n  { q: 1, r: -2, s: 1 },\n]\n\nexport const EPSILON = { q: 1e-6, r: 1e-6, s: -2e-6 }\n","import { isNumber, isString } from 'axis.js'\nimport { DIAGONAL_DIRECTION_COORDINATES, DIRECTION_COORDINATES } from '../hex/constants'\n\n/**\n * Get a hex from a grid.\n *\n * @memberof Grid#\n * @instance\n *\n * @param {(number|point)} keyOrPoint   An index/key or a point.\n * @returns {hex}                       The found hex or `undefined`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 2, height: 2 })\n *\n * grid.get(0)              // { x: 0, y: 0 }\n * grid.get(Hex(0, 1))      // { x: 0, y: 1 }\n * grid.get({ x: 0, y: 1 }) // { x: 0, y: 1 }\n * grid.get([0, 1])         // { x: 0, y: 1 }\n *\n * grid.get(42)             // undefined\n * grid.get(Hex(6, -2))     // undefined\n */\nexport function get(keyOrPoint) {\n  if (isNumber(keyOrPoint)) {\n    return this[keyOrPoint]\n  } else {\n    return this[this.indexOf(keyOrPoint)]\n  }\n}\n\nexport function setFactory({ isValidHex }) {\n  /**\n   * Replace a hex with another hex. This is a safe alternative to using bracket notation (`grid[0] = 'invalid'`).\n   *\n   * If the target hex isn't present in the grid, the new hex is added (using {@link Grid#push}) to the grid.\n   * If the new hex is invalid, nothing changes.\n   *\n   * @memberof Grid#\n   * @instance\n   *\n   * @param {(number|point)} keyOrPoint   The coordinates of the hex that must be replaced.\n   * @param {hex} newHex                  The replacing hex.\n   *\n   * @returns {grid}                      Itself.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0, 0)) // [ { x: 0, y: 0 } ]\n   *\n   * // replace a hex:\n   * grid.set(0, Hex(1, 1))\n   * grid                         // [ { x: 1, y: 1 } ]\n   * // the target hex can also be a point:\n   * grid.set([1, 1], Hex(2, 2))\n   * grid                         // [ { x: 2, y: 2 } ]\n   *\n   * // invalid replace values are ignored:\n   * grid.set(0, 'invalid')\n   * grid                         // [ { x: 2, y: 2 } ]\n   *\n   * // when the target hex isn't present in the grid, the replacing hex is added instead:\n   * grid.set({ x: 9, y: 9 }, Hex(3, 3))\n   * grid                         // [ { x: 2, y: 2 }, { x: 3, y: 3 } ]\n   */\n  return function set(keyOrPoint, newHex) {\n    if (!isValidHex(newHex)) {\n      return this\n    }\n\n    const index = isNumber(keyOrPoint) ? keyOrPoint : this.indexOf(keyOrPoint)\n\n    if (index < 0) {\n      this.push(newHex)\n    } else {\n      this[index] = newHex\n    }\n\n    return this\n  }\n}\n\n/**\n * @memberof Grid#\n * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n *\n * @param {hex} firstHex    The first hex.\n * @param {hex} lastHex     The last hex.\n *\n * @returns {hex[]}         Array (not a {@link grid}) of hexes in a straight line from `firstHex` to (and including) `lastHex`.\n *\n * @example\n * const Grid = Honeycomb.defineGrid()\n * const Hex = Grid.Hex\n * const grid = Grid.rectangle({ width: 4, height: 4 })\n *\n * grid.hexesBetween(Hex(), Hex(3)) // [\n *                                  //    { x: 0, y: 0 },\n *                                  //    { x: 0, y: 1 },\n *                                  //    { x: 1, y: 1 },\n *                                  //    { x: 2, y: 2 },\n *                                  //    { x: 3, y: 2 },\n *                                  //    { x: 3, y: 3 },\n *                                  // ]\n */\nexport function hexesBetween(firstHex, lastHex) {\n  const distance = firstHex.distance(lastHex)\n  const step = 1.0 / Math.max(distance, 1)\n  let hexes = []\n\n  for (let i = 0; i <= distance; i++) {\n    const hex = firstHex\n      .nudge()\n      .lerp(lastHex.nudge(), step * i)\n      .round()\n    hexes.push(this.get(hex))\n  }\n\n  return hexes\n}\n\nexport function hexesInRangeFactory({ isValidHex }) {\n  /**\n   * @memberof Grid#\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#range-coordinate|redblobgames.com}\n   *\n   * @param {hex} centerHex                   A hex to get surrounding hexes from.\n   * @param {number} [range=0]                The range (in hexes) surrounding the center hex.\n   * @param {boolean} [includeCenterHex=true] Whether to include the center hex in the result\n   *\n   * @returns {hex[]}             An array with all hexes surrounding the passed center hex.\n   *                              Only hexes that are present in the grid are returned.\n   *\n   * @throws {Error} When no valid hex is passed.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * const grid = Grid.rectangle({ width: 5, height: 5 })\n   *\n   * grid.hexesInRange(Hex(2, 2), 2)          // [\n   *                                          //    { x: 0, y: 2 },\n   *                                          //    { x: 0, y: 3 },\n   *                                          //    { x: 1, y: 4 },\n   *                                          //    ...\n   *                                          //    { x: 3, y: 0 },\n   *                                          //    { x: 3, y: 1 },\n   *                                          //    { x: 4, y: 2 }\n   *                                          // ]\n   *\n   * // only returns hexes that exist in the grid:\n   * grid.hexesInRange(Hex(0, 0), 1)          // [\n   *                                          //    { x: 0, y: 0 },\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: 1, y: 0 }\n   *                                          // ]\n   *\n   * // exclude center hex:\n   * grid.hexesInRange(Hex(2, 2), 1, false)   // [\n   *                                          //    { x: 1, y: 2 },\n   *                                          //    { x: 1, y: 3 },\n   *                                          //    { x: 1, y: 1 },\n   *                                          //    { x: 2, y: 3 },\n   *                                          //    { x: 3, y: 2 }\n   *                                          // ]\n   */\n  return function hexesInRange(centerHex, range = 0, includeCenterHex = true) {\n    if (!isValidHex(centerHex)) {\n      throw new Error(`Invalid center hex: ${centerHex}.`)\n    }\n\n    if (!this.get(centerHex)) {\n      throw new Error(`Center hex with coordinates ${centerHex} not present in grid.`)\n    }\n\n    let hexes = []\n\n    for (let q = -range; q <= range; q++) {\n      for (let r = Math.max(-range, -q - range); r <= Math.min(range, -q + range); r++) {\n        const hex = this.get(centerHex.cubeToCartesian({ q: centerHex.q + q, r: centerHex.r + r }))\n\n        if (centerHex.equals(hex) && !includeCenterHex) {\n          continue\n        }\n\n        hexes.push(hex)\n      }\n    }\n\n    return hexes.filter(Boolean)\n  }\n}\n\nexport function neighborsOfFactory({ isValidHex, signedModulo, compassToNumberDirection }) {\n  /**\n   * @memberof Grid#\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#neighbors|redblobgames.com}\n   *\n   * @param {hex} hex\n   * A hex to get 1 or more neighbors from.\n   * @param {((COMPASS_DIRECTION|number)[]|COMPASS_DIRECTION|number|all)} [directions=all]\n   * 1 or more directions. Either (an array of) {@link COMPASS_DIRECTION|compass directions} or numbers or the string `'all'`.\n   * @param {boolean} [diagonal=false]\n   * Whether to get the diagonal neighbor. See {@link https://www.redblobgames.com/grids/hexagons/#neighbors-diagonal|redblobgames.com}.\n   *\n   * @returns {hex[]}\n   * An array with the neighboring hex for each queried direction or `undefined` if the hex doesn't exist in the grid.\n   *\n   * @throws {Error} When no valid hex is passed.\n   * @throws {Error} When the direction is invalid for the hex.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ orientation: 'pointy' })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * // conveniently creates a grid consisting of a hex surrounded by 6 hexes:\n   * const grid = Grid.hexagon({ radius: 1 })\n   *\n   * // all neighbors:\n   * grid.neighborsOf(Hex())          // [\n   *                                  //    { x: 1, y: 0 },\n   *                                  //    { x: 0, y: 1 },\n   *                                  //    { x: -1, y: 1 },\n   *                                  //    { x: -1, y: 0 },\n   *                                  //    { x: -1, y: -1 },\n   *                                  //    { x: 0, y: -1 },\n   *                                  // ]\n   * // specific neighbor:\n   * grid.neighborsOf(Hex(), 'NW')    // [{ x: -1, y: -1 }]\n   * grid.neighborsOf(Hex(), 4)       // [{ x: -1, y: -1 }]\n   *\n   * // multiple neighbors:\n   * grid.neighborsOf(Hex(), ['SE', 'SW'])    // [\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: -1, y: 1 }\n   *                                          // ]\n   *\n   * grid.neighborsOf(Hex(), [1, 2])          // [\n   *                                          //    { x: 0, y: 1 },\n   *                                          //    { x: -1, y: 1 }\n   *                                          // ]\n   * // diagonal neighbor:\n   * grid.neighborsOf(Hex(-1, 0), 'E', true)  // [{ x: 0, y: -1 }]\n   *\n   * // returns undefined for hexes that aren't present in the grid:\n   * grid.neighborsOf(Hex(-1, -1), 'NW')      // [undefined]\n   */\n  return function neighborsOf(hex, directions = 'all', diagonal = false) {\n    if (!isValidHex(hex)) {\n      throw new Error(`Invalid hex: ${hex}.`)\n    }\n\n    const coordinates = diagonal ? DIAGONAL_DIRECTION_COORDINATES : DIRECTION_COORDINATES\n\n    if (directions === 'all') {\n      directions = [0, 1, 2, 3, 4, 5]\n    }\n\n    return (directions = []\n      // ensure directions is an array\n      .concat(directions)\n      .map(direction => {\n        // todo: move this to a util, also grid/statics.js#277\n        if (isString(direction)) {\n          direction = compassToNumberDirection(direction, hex.orientation)\n        }\n\n        if (direction < 0 || direction > 5) {\n          direction = signedModulo(direction, 6)\n        }\n\n        const { q, r } = coordinates[direction]\n        return this.get(hex.cubeToCartesian({ q: hex.q + q, r: hex.r + r }))\n      }))\n  }\n}\n\n/**\n * @memberof Grid#\n * @instance\n *\n * @returns {number}    The width of the grid in points/pixels.\n */\nexport function pointWidth() {\n  if (this.length === 0) {\n    return 0\n  }\n\n  // sort hexes from left to right and take the first and last\n  const { 0: mostLeft, length, [length - 1]: mostRight } = this[0].isPointy()\n    ? [...this].sort((a, b) => b.s - a.s || a.q - b.q)\n    : [...this].sort((a, b) => a.q - b.q)\n\n  return mostRight.toPoint().x - mostLeft.toPoint().x + this[0].width()\n}\n\n/**\n * @memberof Grid#\n * @instance\n *\n * @returns {number}    The heigth of the grid in points/pixels.\n */\nexport function pointHeight() {\n  if (this.length === 0) {\n    return 0\n  }\n\n  // sort hexes from top to bottom and take the first and last\n  const { 0: mostUp, length, [length - 1]: mostDown } = this[0].isPointy()\n    ? [...this].sort((a, b) => a.r - b.r)\n    : [...this].sort((a, b) => b.s - a.s || a.r - b.r)\n\n  return mostDown.toPoint().y - mostUp.toPoint().y + this[0].height()\n}\n","import { isString } from 'axis.js'\nimport { DIRECTION_COORDINATES } from '../hex/constants'\nimport { offsetFromZero } from '../utils'\n\nexport function pointToHexFactory({ Hex }) {\n  /**\n   * Converts the passed {@link point} to a hex. Internally calls {@link Hex#fromPoint}.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link Hex#fromPoint}\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 50 })\n   * const Grid = Honeycomb.defineGrid(Hex)\n   * const Point = Honeycomb.Point\n   *\n   * Grid.pointToHex(Point(120, 280))     // { x: 0, y: 3 }\n   * Grid.pointToHex(120, 280)            // { x: 0, y: 3 }\n   * Grid.pointToHex({ x: 120, y: 280 })  // { x: 0, y: 3 }\n   * Grid.pointToHex([ 120, 280 ])        // { x: 0, y: 3 }\n   */\n  return function pointToHex(pointOrX, y) {\n    return Hex().fromPoint(pointOrX, y)\n  }\n}\n\nexport function parallelogramFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [parallelogram](https://en.wikipedia.org/wiki/Parallelogram) ▱.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.width                The width (in hexes).\n   * @param {number} options.height               The height (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex.\n   * @param {(1|3|5)} [options.direction=1]       The direction (from the start hex) in which to create the shape.\n   *                                              Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a parallelogram arrangement.\n   */\n  return function parallelogram({\n    width,\n    height,\n    start,\n    direction = 1,\n    /**\n     * Callback of a {@link Grid} shape method.\n     * Gets called for each hex that's about to be added to the grid.\n     *\n     * @callback onCreate\n     * @param {hex} hex     The freshly created hex, just before it's added to the grid.\n     * @param {grid} grid   The grid (for as far as it's created).\n     * @returns {void}      Nothing.\n     */\n    onCreate = () => {},\n  }) {\n    start = Hex(start)\n    // TODO: validate direction\n    const DIRECTIONS = {\n      1: ['q', 'r', 's'],\n      3: ['r', 's', 'q'],\n      5: ['s', 'q', 'r'],\n    }\n    const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n    const grid = new Grid()\n    grid.width = width\n    grid.height = height\n    grid.start = start\n    grid.direction = direction\n\n    for (let first = 0; first < width; first++) {\n      for (let second = 0; second < height; second++) {\n        const hex = Hex({\n          [firstCoordinate]: first + start[firstCoordinate],\n          [secondCoordinate]: second + start[secondCoordinate],\n          [thirdCoordinate]: -first - second + start[thirdCoordinate],\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function triangleFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [(equilateral) triangle](https://en.wikipedia.org/wiki/Equilateral_triangle) △.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.size                 The side length (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex. **Note**: it's not the first hex, but rather a hex relative to the triangle.\n   * @param {(1|5)} [options.direction=1]         The direction in which to create the shape. Each direction corresponds to a different arrangement of hexes. In this case a triangle pointing up (`direction: 1`) or down (`direction: 5`) (with pointy hexes) or right (`direction: 1`) or left (`direction: 5`) (with flat hexes).\n   *                                              Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a triangle arrangement.\n   */\n  return function triangle({ size, start, direction = 1, onCreate = () => {} }) {\n    start = Hex(start)\n    // TODO: validate direction\n    const DIRECTIONS = {\n      1: {\n        rStart: () => 0,\n        rEnd: q => size - q,\n      },\n      5: {\n        rStart: q => size - q,\n        rEnd: () => size + 1,\n      },\n    }\n    const { rStart, rEnd } = DIRECTIONS[direction]\n    const grid = new Grid()\n    grid.size = size\n    grid.start = start\n    grid.direction = direction\n\n    for (let q = 0; q < size; q++) {\n      for (let r = rStart(q); r < rEnd(q); r++) {\n        const hex = Hex({\n          q: q + start.q,\n          r: r + start.r,\n          s: -q - r + start.s,\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function hexagonFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a [hexagon](https://en.wikipedia.org/wiki/Hexagon) ⬡.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a hexagon arrangement.\n   */\n  return function hexagon({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    const grid = new Grid()\n    grid.radius = radius\n    grid.center = center\n\n    for (let q = -radius; q <= radius; q++) {\n      const startR = Math.max(-radius, -q - radius)\n      const endR = Math.min(radius, -q + radius)\n\n      for (let r = startR; r <= endR; r++) {\n        const hex = Hex({\n          q: q + center.q,\n          r: r + center.r,\n          s: -q - r + center.s,\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }) {\n  /**\n   * Creates a grid in the shape of a [rectangle](https://en.wikipedia.org/wiki/Rectangle) ▭.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/implementation.html#map-shapes|redblobgames.com}\n   *\n   * @todo Validate params\n   * @todo Move duplicate code to util\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.width                The width (in hexes).\n   * @param {number} options.height               The height (in hexes).\n   * @param {hex} [options.start=Hex(0)]          The start hex.\n   * @param {(COMPASS_DIRECTION|number)} [options.direction=E|S]\n   * The direction (from the start hex) in which to create the shape.\n   * Defaults to `0` (`E`) for pointy hexes and `1` (`S`) for flat hexes.\n   * Each direction corresponds to a different arrangement of hexes.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a rectangular arrangement.\n   */\n  return function rectangle({\n    width,\n    height,\n    start,\n    direction = Hex().isPointy() ? 0 : 1, // E or S\n    onCreate = () => {},\n  }) {\n    start = Hex(start)\n\n    if (isString(direction)) {\n      direction = compassToNumberDirection(direction, start.orientation)\n    }\n\n    if (direction < 0 || direction > 5) {\n      direction = signedModulo(direction, 6)\n    }\n\n    const DIRECTIONS = [\n      ['q', 'r', 's'],\n      ['r', 'q', 's'],\n      ['r', 's', 'q'],\n      ['s', 'r', 'q'],\n      ['s', 'q', 'r'],\n      ['q', 's', 'r'],\n    ]\n    const [firstCoordinate, secondCoordinate, thirdCoordinate] = DIRECTIONS[direction]\n    const [firstStop, secondStop] = start.isPointy() ? [width, height] : [height, width]\n    const grid = new Grid()\n    grid.width = width\n    grid.height = height\n    grid.start = start\n    grid.direction = direction\n\n    for (let second = 0; second < secondStop; second++) {\n      const secondOffset = offsetFromZero(start.offset, second)\n\n      for (let first = -secondOffset; first < firstStop - secondOffset; first++) {\n        const hex = Hex({\n          [firstCoordinate]: first + start[firstCoordinate],\n          [secondCoordinate]: second + start[secondCoordinate],\n          [thirdCoordinate]: -first - second + start[thirdCoordinate],\n        })\n        onCreate(hex, grid)\n        grid.push(hex)\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function ringFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a ring.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rings|redblobgames.com}\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a ring arrangement.\n   */\n  return function ring({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    const grid = new Grid()\n    grid.radius = radius\n    grid.center = center\n\n    const { q, r, s } = center\n    let hex = Hex({ q, r: r - radius, s: s + radius })\n\n    for (let i = 0; i < 6; i++) {\n      for (let j = 0; j < radius; j++) {\n        onCreate(hex, grid)\n        grid.push(hex)\n\n        const { q, r, s } = DIRECTION_COORDINATES[i]\n        hex = Hex({ q: hex.q + q, r: hex.r + r, s: hex.s + s })\n      }\n    }\n\n    return grid\n  }\n}\n\nexport function spiralFactory({ Grid, Hex }) {\n  /**\n   * Creates a grid in the shape of a spiral starting from the center outward.\n   * The result is the same as a hexagon, but the order of hexes is different.\n   *\n   * @memberof Grid\n   * @static\n   * @method\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rings-spiral|redblobgames.com}\n   *\n   * @param {Object} options                      An options object.\n   * @param {number} options.radius               The radius (in hexes) *excluding* the center hex.\n   * @param {hex} [options.center=Hex(0)]         The center hex.\n   * @param {onCreate} [options.onCreate=no-op]   Callback that's called for each hex. Defaults to a {@link https://en.wikipedia.org/wiki/NOP|no-op}.\n   *\n   * @returns {grid}                              Grid of hexes in a spiral arrangement.\n   */\n  return function spiral({ radius, center, onCreate = () => {} }) {\n    center = Hex(center)\n\n    let grid = new Grid()\n\n    onCreate(center, grid)\n    grid.push(center)\n\n    for (let i = 1; i <= radius; i++) {\n      grid = grid.concat(this.ring({ radius: i, center, onCreate }))\n    }\n\n    grid.radius = radius\n    grid.center = center\n\n    return grid\n  }\n}\n","export function addFactory({ Point }) {\n  /**\n     * @memberof Point#\n\n     * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n     * @param {number} [pointOrX.x=]                The x coordinate.\n     * @param {number} [pointOrX.y=]                The y coordinate.\n     * @param {number} [y=]                         The y coordinate.\n     *\n     * @returns {point}         The sum of the passed point's coordinates to the current point's.\n     */\n  return function add(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x + x, this.y + y)\n  }\n}\n\nexport function subtractFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The difference between the passed point's coordinates and the current point's.\n   */\n  return function subtract(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x - x, this.y - y)\n  }\n}\n\nexport function multiplyFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The multiplication of the passed point's coordinates and the current point's.\n   */\n  return function multiply(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x * x, this.y * y)\n  }\n}\n\nexport function divideFactory({ Point }) {\n  /**\n   * @memberof Point#\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}         The division of the current point's coordinates and the passed point's.\n   */\n  return function divide(pointOrX, y) {\n    let x\n    ;({ x, y } = Point(pointOrX, y))\n    return Point(this.x / x, this.y / y)\n  }\n}\n","import { isNumber, isArray, isObject } from 'axis.js'\nimport * as methods from './prototype'\n\n/**\n * See {@link Point}.\n *\n * @function Point\n * @memberof Honeycomb\n * @static\n */\n\nexport default function PointFactory({ ensureXY }) {\n  const prototype = {\n    add: methods.addFactory({ Point }),\n    subtract: methods.subtractFactory({ Point }),\n    multiply: methods.multiplyFactory({ Point }),\n    divide: methods.divideFactory({ Point }),\n  }\n\n  /**\n   * Factory function for creating two-dimensional points.\n   *\n   * @function Point\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {point}                             A point.\n   *\n   * @example\n   * const Point = Honeycomb.Point\n   *\n   * Point()                  // { x: 0, y: 0 }\n   * Point(1)                 // { x: 1, y: 1 }\n   * Point(1, 2)              // { x: 1, y: 2 }\n   *\n   * Point([])                // { x: 0, y: 0 }\n   * Point([1])               // { x: 1, y: 1 }\n   * Point([1, 2])            // { x: 1, y: 2 }\n   *\n   * Point({})                // { x: 0, y: 0 }\n   * Point({ x: 1 })          // { x: 1, y: 1 }\n   * Point({ y: 2 })          // { x: 2, y: 2 }\n   * Point({ x: 1, y: 2 })    // { x: 1, y: 2 }\n   */\n  function Point(pointOrX, y) {\n    let coordinates\n    /**\n     * An object with just an `x` and a `y` property.\n     *\n     * Create your own:\n     * ```javascript\n     * const point = { x: 1, y: 2 }\n     * ```\n     *\n     * Or use the included {@link Point} factory:\n     * ```javascript\n     * const point = Honeycomb.Point(1, 2)\n     * ```\n     *\n     * @typedef {Object} point\n     * @property {number} x (horizontal) x coordinate\n     * @property {number} y (vertical) y coordinate\n     */\n\n    if (isNumber(pointOrX)) {\n      coordinates = ensureXY(pointOrX, y)\n    } else if (isArray(pointOrX)) {\n      coordinates = ensureXY(...pointOrX)\n    } else if (isObject(pointOrX)) {\n      coordinates = ensureXY(pointOrX.x, pointOrX.y)\n    } else {\n      coordinates = ensureXY(0)\n    }\n\n    return Object.assign(Object.create(prototype), coordinates)\n  }\n\n  return Point\n}\n","import { ensureXY } from '../utils'\nimport PointFactory from '../point'\n\nconst Point = PointFactory({ ensureXY })\n\n/**\n * @private\n *\n * The only way to prevent setting invalid items in a grid (`grid[0] = 'not a hex'`) is by using proxies.\n * A proxy can have a `set` trap that can prevent the setting of invalid hexes.\n *\n * Some approaches include:\n * 1. Wrapping the grid instance returned from GridFactory in a proxy.\n * 2. Putting a proxy in the prototype chain of Grid (this \"shields\" the Array prototype methods).\n * 3. Using a proxy to forward certain calls to the Array prototype (and not extending Array at all).\n */\n\nexport default class Grid extends Array {\n  /**\n   * @private\n   * @param {*} value     Any value.\n   * @returns {boolean}   Whether the passed value is a valid hex.\n   */\n  static isValidHex(value) {\n    return (value || {}).__isHoneycombHex === true\n  }\n\n  /**\n   * @memberof Grid#\n   * @override\n   * @throws {TypeError}  It makes no sense for a grid to fill it with arbitrary values, because it should only contain valid hexes.\n   *\n   * @returns {TypeError} An error.\n   */\n  fill() {\n    throw new TypeError('Grid.prototype.fill is not implemented')\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/includes|Array#includes},\n   * but searches the passed hex (which can also be a {@link point}.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point             The coordinates to search for.\n   * @param {number} [fromIndex=0]    Optional index to start searching.\n   *\n   * @returns {boolean}               Whether the hex is included in the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0))    // [ { x: 0, y: 0 } ]\n   *\n   * grid.includes(Hex(0))        // true\n   * grid.includes([0, 0])        // true\n   * grid.includes(Hex(0), 1)     // false\n   * grid.includes(Hex(5, 7))     // false\n   */\n  includes(point, fromIndex = 0) {\n    return !!(this.indexOf(point, fromIndex) + 1)\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/indexOf|Array#indexOf},\n   * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point             The coordinates to search for.\n   * @param {number} [fromIndex=0]    Optional index to start searching.\n   *                                  If negative, it is taken as the offset from the end of the grid.\n   *\n   * @returns {number}                The index of the found hex (first from the left) or -1 if the hex wasn't found.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0), Hex(1), Hex(0))\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 1 },\n   * //    { x: 0, y: 0 }\n   * // ]\n   *\n   * grid.indexOf(Hex(0))     // 0\n   * grid.indexOf([0, 0])     // 0\n   * grid.indexOf(Hex(0), 1)  // 2\n   * grid.indexOf(Hex(5, 7))  // -1\n   */\n  indexOf(point, fromIndex = 0) {\n    const { length } = this\n    let i = Number(fromIndex)\n\n    point = Point(point)\n    i = Math.max(i >= 0 ? i : length + i, 0)\n\n    for (i; i < length; i++) {\n      if (this[i].equals(point)) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/lastIndexOf|Array#lastIndexOf},\n   * but accepts a {@link point} and internally uses {@link Hex#equals} as a comparator.\n   *\n   * Because all hexes will have different coordinates in most grids, this method behaves the same as {@link Grid#indexOf}.\n   * This method might have a slightly better performance if you know the search hex is at the end of the grid.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {point} point                 The coordinates to search for.\n   * @param {number} [fromIndex=length-1] Optional index to start searching back from.\n   *                                      If negative, it is taken as the offset from the end of the grid.\n   *\n   * @returns {number}                    The last index of the found hex or -1 if the hex wasn't found.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid(Hex(0), Hex(1), Hex(0))\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 1 },\n   * //    { x: 0, y: 0 }\n   * // ]\n   *\n   * grid.lastIndexOf(Hex(0))     // 2\n   * grid.lastIndexOf([0, 0])     // 2\n   * grid.lastIndexOf(Hex(0), 1)  // 0\n   * grid.lastIndexOf(Hex(5, 7))  // -1\n   */\n  lastIndexOf(point, fromIndex = this.length - 1) {\n    const { length } = this\n    let i = Number(fromIndex)\n\n    point = Point(point)\n    i = i >= 0 ? Math.min(i, length - 1) : length + i\n\n    for (i; i >= 0; i--) {\n      if (this[i].equals(point)) {\n        return i\n      }\n    }\n\n    return -1\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/push|Array#push},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {...hex} [hexes]  Hexes to add to the end of the grid. Invalid hexes are ignored.\n   *\n   * @returns {number}        The new length of the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   *\n   * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n   * grid.push(Hex(1))            // 2\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n   *\n   * grid.push('invalid')         // 2\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 1 }]\n   */\n  push(...hexes) {\n    return super.push(...hexes.filter(Grid.isValidHex))\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice|Array#splice},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {number} start                        Index at which to start changing the grid.\n   * @param {number} [deleteCount=length-start]   Amount of hexes to delete.\n   * @param {...hex} [hexes=[]]                   The hexes to add to the grid, beginning at the `start`.\n   *\n   * @returns {hex[]}                             A grid with the deleted hexes (if any).\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   * const grid = Grid.rectangle({ width: 2, height: 1 })\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 0 },\n   * //    { x: 0, y: 1 },\n   * //    { x: 1, y: 1 }\n   * // ]\n   *\n   * grid.splice(2)               // [{ x: 0, y: 1 }, { x: 1, y: 1 }] <- deleted hexes\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }] <- leftover hexes\n   *\n   * grid.splice(2, 1)            // [{ x: 0, y: 1 }]\n   * grid                         // [{ x: 0, y: 0 }, { x: 1, y: 0 }, { x: 1, y: 1 }]\n   *\n   * grid.splice(2, 1, Hex(2))    // [{ x: 0, y: 1 }]\n   * grid\n   * // [\n   * //    { x: 0, y: 0 },\n   * //    { x: 1, y: 0 },\n   * //    { x: 2, y: 2 },\n   * //    { x: 1, y: 1 }\n   * // ]\n   */\n  splice(start, deleteCount, ...hexes) {\n    // when deleteCount is undefined/null, it's casted to 0, deleting 0 hexes\n    // this is not according to spec: it should delete all hexes (starting from `start`)\n    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/splice\n    if (deleteCount == null) {\n      return super.splice(start)\n    }\n\n    return super.splice(start, deleteCount, ...hexes.filter(Grid.isValidHex))\n  }\n\n  /**\n   * Identical to {@link https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/unshift|Array#unshift},\n   * but filters out any passed invalid hexes.\n   *\n   * @memberof Grid#\n   * @override\n   *\n   * @param {...hex} [hexes]  Hexes to add to the start of the grid. Invalid hexes are ignored.\n   *\n   * @returns {number}        The new length of the grid.\n   *\n   * @example\n   * const Grid = Honeycomb.defineGrid()\n   * const Hex = Grid.Hex\n   *\n   * const grid = Grid(Hex(0))    // [{ x: 0, y: 0 }]\n   * grid.unshift(Hex(1))         // 2\n   * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n   *\n   * grid.unshift('invalid')      // 2\n   * grid                         // [{ x: 1, y: 1 }, { x: 0, y: 0 }]\n   */\n  unshift(...hexes) {\n    return super.unshift(...hexes.filter(Grid.isValidHex))\n  }\n}\n","import { isArray, isNumber } from 'axis.js'\nimport { offsetFromZero } from '../utils'\nimport { EPSILON } from './constants'\n\nexport function setFactory({ Hex }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @param {*} coordinates   Same parameters as the {@link Hex} factory.\n   * @returns {hex}           Itself with the passed parameters merged into it.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   *\n   * const hex = Hex({ x: 1, y: 2, a: 3, b: 4 })          // { a: 3, b: 4, x: 1, y: 2 }\n   * const updatedHex = hex.set({ x: 0, y: -1, b: 5 })    // { a: 3, b: 5, x: 0, y: -1 }\n   * hex === updatedHex                                   // true: hex is updated in-place\n   */\n  return function set(...args) {\n    return Object.assign(this, Hex(...args))\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().coordinates()      // { x: 0, y: 0 }\n * Hex(1, 2).coordinates()  // { x: 1, y: 2 }\n */\nexport function coordinates() {\n  return { x: this.x, y: this.y }\n}\n\n/**\n * @memberof Hex#\n * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cube()     // { q: 0, r: 0, s: 0 }\n * Hex(1, 2).cube() // { q: 0, r: 2, s: -2 }\n */\nexport function cube() {\n  return { q: this.q, r: this.r, s: this.s }\n}\n\n/**\n * @memberof Hex#\n *\n * @todo make this a static (and instance?) method\n *\n * @param {Object} cubeCoordinates      At least the `q` and `r` cube coordinates.\n * @param {number} cubeCoordinates.q    The `q` cube coordinate.\n * @param {number} cubeCoordinates.r    The `r` cube coordinate.\n * @param {number} [cubeCoordinates.s]  The optional `s` cube coordinate.\n *\n * @returns {Object}                    The hex's cartesian `x` and `y` coordinates.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().cubeToCartesian({ q: 1, r: 2, s: -3 }) // { x: 2, y: 2 }\n * // the `s` coordinate isn't required:\n * Hex().cubeToCartesian({ q: -3, r: 5 })       // { x: -1, y: 5 }\n */\nexport function cubeToCartesian({ q, r }) {\n  let x, y\n\n  if (this.isPointy()) {\n    x = q + offsetFromZero(this.offset, r)\n    y = r\n  } else {\n    x = q\n    y = r + offsetFromZero(this.offset, q)\n  }\n\n  return { x, y }\n}\n\nexport function cartesianToCubeFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   *\n   * @todo make this a static (and instance?) method\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {Object}    The hex's cube `q`, `r` and `s` coordinates.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   * const Point = Honeycomb.Point\n   *\n   * Hex().cartesianToCube(Point(4, -2))      // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube(4, -2)             // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube({ x: 4, y: -2 })   // { q: 5, r: -2, s: -3 }\n   * Hex().cartesianToCube([4, -2])           // { q: 5, r: -2, s: -3 }\n   */\n  return function cartesianToCube(pointOrX, y) {\n    let x, q, r\n    ;({ x, y } = Point(pointOrX, y))\n\n    if (this.isPointy()) {\n      q = x - offsetFromZero(this.offset, y)\n      r = y\n    } else {\n      q = x\n      r = y - offsetFromZero(this.offset, x)\n    }\n\n    return { q, r, s: -q - r }\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a pointy ⬢ orientation.\n */\nexport function isPointy() {\n  return this.orientation.toLowerCase() === 'pointy'\n}\n\n/**\n * @memberof Hex#\n * @returns {boolean}   Whether hexes have a flat ⬣ orientation.\n */\nexport function isFlat() {\n  return this.orientation.toLowerCase() === 'flat'\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (horizontal) width of a hex.\n */\nexport function width() {\n  const { xRadius } = this.size\n  return this.isPointy() ? xRadius * Math.sqrt(3) : xRadius * 2\n}\n\n/**\n * @memberof Hex#\n * @returns {number}    The (vertical) height of a hex.\n */\nexport function height() {\n  const { yRadius } = this.size\n  return this.isPointy() ? yRadius * 2 : yRadius * Math.sqrt(3)\n}\n\nexport function cornersFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point[]}\n   * Array of corner points relative to the {@link Hex#origin|hex's origin}.\n   * Starting at the top right corner for pointy hexes and the right corner for flat hexes.\n   *\n   * @example\n   * // a hex's origin defaults to its top left corner (as if it's a rectangle)\n   * const Hex1 = Honeycomb.extendHex({ size: 30 })\n   * Hex1().corners() // [\n   *                  //    { x: 51.96152422706631, y: 15 },\n   *                  //    { x: 51.96152422706631, y: 45 },\n   *                  //    { x: 25.980762113533157, y: 60 },\n   *                  //    { x: 0, y: 45 },\n   *                  //    { x: 0, y: 15 },\n   *                  //    { x: 25.980762113533157, y: 0 }\n   *                  // ]\n   *\n   * // set the origin to a hex's center\n   * const Hex2 = Honeycomb.extendHex({ size: 30, origin: [25.980762113533157, 30] })\n   * Hex2().corners() // [\n   *                  //    { x: 25.980762113533157, y: -15 },\n   *                  //    { x: 25.980762113533157, y: 15 },\n   *                  //    { x: 0, y: 30 },\n   *                  //    { x: -25.980762113533157, y: 15 },\n   *                  //    { x: -25.980762113533157, y: -15 },\n   *                  //    { x: 0, y: -30 }\n   *                  // ]\n   */\n  return function corners() {\n    const width = this.width()\n    const height = this.height()\n    const { x, y } = this.origin\n\n    if (this.isPointy()) {\n      return [\n        Point(width - x, height * 0.25 - y),\n        Point(width - x, height * 0.75 - y),\n        Point(width * 0.5 - x, height - y),\n        Point(0 - x, height * 0.75 - y),\n        Point(0 - x, height * 0.25 - y),\n        Point(width * 0.5 - x, 0 - y),\n      ]\n    } else {\n      return [\n        Point(width - x, height * 0.5 - y),\n        Point(width * 0.75 - x, height - y),\n        Point(width * 0.25 - x, height - y),\n        Point(0 - x, height * 0.5 - y),\n        Point(width * 0.25 - x, 0 - y),\n        Point(width * 0.75 - x, 0 - y),\n      ]\n    }\n  }\n}\n\nexport function centerFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point} Point relative to the {@link Hex#origin|hex's origin}.\n   * Note that the default origin is the top left corner, so the default center is\n   * `{ x: hexWidth / 2, y: hexHeight / 2 }`.\n   *\n   * @example\n   * const Hex1 = Honeycomb.extendHex({ size: 10 })\n   * Hex1().center()  // { x: 8.660254037844386, y: 10 }\n   *\n   * const Hex2 = Honeycomb.extendHex({ size: 10, origin: [5, 5] })\n   * Hex2().center()  // { x: 3.6602540378443855, y: 5 }\n   */\n  return function center() {\n    const { x, y } = this.origin\n    return Point(this.width() / 2 - x, this.height() / 2 - y)\n  }\n}\n\nexport function toPointFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   * @returns {point} The hex's origin point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 30 })\n   * Hex().toPoint()          // { x: 0, y: 0 }\n   * Hex(-2, -5).toPoint()    // { x: -77.94228634059947, y: -225 }\n   */\n  return function toPoint() {\n    const { q, r, size } = this\n    const { xRadius, yRadius } = size\n    let x, y\n\n    if (this.isPointy()) {\n      x = xRadius * Math.sqrt(3) * (q + r / 2)\n      y = ((yRadius * 3) / 2) * r\n    } else {\n      x = ((xRadius * 3) / 2) * q\n      y = yRadius * Math.sqrt(3) * (r + q / 2)\n    }\n\n    return Point(x, y)\n  }\n}\n\nexport function fromPointFactory({ Point, Hex }) {\n  /**\n   * Returns a hex from the passed {@link point}.\n   *\n   * @memberof Hex\n   * @instance\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#pixel-to-hex|redblobgames.com}\n   *\n   * @param {(number|number[]|point)} [pointOrX=] The x coordinate or an array with 2 numbers or an object with an `x` and `y` coordinate.\n   * @param {number} [pointOrX.x=]                The x coordinate.\n   * @param {number} [pointOrX.y=]                The y coordinate.\n   * @param {number} [y=]                         The y coordinate.\n   *\n   * @returns {hex}                               A hex (with rounded coordinates) that contains the passed point.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({ size: 50 })\n   * const Point = Honeycomb.Point\n   * const hex = Hex()\n   *\n   * hex.fromPoint(Point(120, 280))     // { x: 0, y: 3 }\n   * hex.fromPoint(120, 280)            // { x: 0, y: 3 }\n   * hex.fromPoint({ x: 120, y: 280 })  // { x: 0, y: 3 }\n   * hex.fromPoint([ 120, 280 ])        // { x: 0, y: 3 }\n   */\n  return function fromPoint(pointOrX, y) {\n    const { xRadius, yRadius } = this.size\n    let x, q, r\n    ;({ x, y } = Point(pointOrX, y).subtract(this.center()))\n\n    // inspired by https://github.com/gojuno/hexgrid-py\n    // and simplified by https://www.symbolab.com/solver/simplify-calculator/simplify\n    if (this.isPointy()) {\n      q = (Math.sqrt(3) * x) / (3 * xRadius) - y / (3 * yRadius)\n      r = (2 / 3) * (y / yRadius)\n    } else {\n      q = (2 / 3) * (x / xRadius)\n      r = (Math.sqrt(3) * y) / (3 * yRadius) - x / (3 * xRadius)\n    }\n\n    return Hex({ q, r, s: -q - r }).round()\n  }\n}\n\nexport function addFactory({ Hex, Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @todo Accept any number of hexes to add.\n   *\n   * @param {point} point The hex (or point) that will be added to the current.\n   * @returns {hex}       A *new* hex where the passed hex's coordinates are added to the current.\n   *                      Any custom properties are copied.\n   */\n  return function add(point) {\n    const { x, y } = Point(point)\n    return Hex(this.x + x, this.y + y, { ...this })\n  }\n}\n\nexport function subtractFactory({ Hex, Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @todo Accept any number of hexes to subtract.\n   *\n   * @param {point} point The hex (or point) that will be subtracted from the current.\n   * @returns {hex}       A *new* hex where the passed hex's coordinates are subtracted from the current.\n   *                      Any custom properties are copied.\n   */\n  return function subtract(point) {\n    const { x, y } = Point(point)\n    return Hex(this.x - x, this.y - y, { ...this })\n  }\n}\n\nexport function equalsFactory({ Point }) {\n  /**\n   * @memberof Hex#\n   * @instance\n   *\n   * @param {point} point The hex (or point) whose coordinates will be compared against the current hex.\n   * @returns {boolean}   Whether the coordinates of the current and the passed point are equal.\n   */\n  return function equals(point) {\n    if (point != null && (isArray(point) || (isNumber(point.x) && isNumber(point.y)))) {\n      const { x, y } = Point(point)\n      return this.x === x && this.y === y\n    }\n\n    return false\n  }\n}\n\n/**\n * @memberof Hex#\n *\n * @see {@link https://www.redblobgames.com/grids/hexagons/#distances|redblobgames.com}\n *\n * @param   {hex} hex   The last hex (cannot be a {@link point}).\n * @returns {number}    The amount of hexes from the current to (and excluding) the last hex.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n *\n * Hex().distance(Hex(1, 0))        // 1\n * Hex(-2, -2).distance(Hex(4, 1))  // 8\n */\nexport function distance(hex) {\n  return Math.max(Math.abs(this.q - hex.q), Math.abs(this.r - hex.r), Math.abs(this.s - hex.s))\n}\n\nexport function roundFactory({ Hex }) {\n  /**\n   * Rounds the current floating point hex coordinates to their nearest integer hex coordinates.\n   *\n   * @memberof Hex#\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#rounding|redblobgames.com}\n   *\n   * @returns {hex}   A *new* hex with rounded coordinates.\n   *                  Any custom properties are copied.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex()\n   * Hex(3.1415, 0.5).round() // { x: 3, y: 1 }\n   */\n  return function round() {\n    let { q, r, s } = this\n    let roundedQ = Math.round(q)\n    let roundedR = Math.round(r)\n    let roundedS = Math.round(s)\n    const diffQ = Math.abs(q - roundedQ)\n    const diffR = Math.abs(r - roundedR)\n    const diffS = Math.abs(s - roundedS)\n\n    if (diffQ > diffR && diffQ > diffS) {\n      roundedQ = -roundedR - roundedS\n    } else if (diffR > diffS) {\n      roundedR = -roundedQ - roundedS\n    } else {\n      roundedS = -roundedQ - roundedR\n    }\n\n    return Hex({ ...this, q: roundedQ, r: roundedR, s: roundedS })\n  }\n}\n\nexport function lerpFactory({ Hex }) {\n  /**\n   * Returns an interpolation between the current hex and the passed hex for a `t` between 0 and 1.\n   * More info on [wikipedia](https://en.wikipedia.org/wiki/Linear_interpolation).\n   *\n   * @memberof Hex#\n   *\n   * @param   {hex} hex   The other hex (cannot be a {@link point}).\n   * @param   {number} t  A \"parameter\" between 0 and 1.\n   *\n   * @returns {hex}       A new hex (likely with floating point coordinates).\n   *                      Any custom properties are copied.\n   */\n  return function lerp(hex, t) {\n    const q = this.q * (1 - t) + hex.q * t\n    const r = this.r * (1 - t) + hex.r * t\n    return Hex({ ...this, q, r, s: -q - r })\n  }\n}\n\nexport function nudgeFactory({ Hex }) {\n  /**\n   * @memberof Hex#\n   * @see {@link https://www.redblobgames.com/grids/hexagons/#line-drawing|redblobgames.com}\n   *\n   * @returns {hex}   A *new* hex with a tiny offset from the current hex.\n   *                  Useful for interpolating in a consistent direction.\n   */\n  return function nudge() {\n    const { q, r, s } = EPSILON\n    return Hex({ ...this, q: this.q + q, r: this.r + r, s: this.s + s })\n  }\n}\n\n/**\n * @memberof Hex#\n * @returns {string}    A string representation of the hex.\n */\nexport function toString() {\n  return `${this.x},${this.y}`\n}\n","import { isArray, isNumber, isObject } from 'axis.js'\nimport * as methods from './prototype'\nimport * as statics from './statics'\n\nexport const staticMethods = {\n  thirdCoordinate: statics.thirdCoordinate,\n}\n\nexport default function extendHexFactory({ ensureXY, normalizeRadiuses, Point }) {\n  /**\n   * @function extendHex\n   *\n   * @memberof Honeycomb\n   * @static\n   *\n   * @description\n   * This function can be used to create custom hexes by extending the default Hex prototype.\n   *\n   * All properties of the object passed to `extendHex()` will be added to the prototype of the resulting {@link Hex} factory.\n   * To add properties to individual hexes (instances), pass them to the {@link Hex} factory.\n   *\n   * @todo validate orientation, origin\n   * @todo warn when properties are overriden\n   *\n   * @param {Object} [prototype={}]   An object that's used as the prototype for all hexes in a grid.\n   *                                  **Warning:** properties in this object will overwrite properties with the same name in the default prototype.\n   *\n   * @returns {Hex}                   A function to produce hexes that are all linked to the same prototype.\n   *\n   * @example\n   * const Hex = Honeycomb.extendHex({\n   *     size: 50,\n   *     orientation: 'flat',\n   *     customProperty: `I'm custom 😃`,\n   *     customMethod() {\n   *         return `${this.customProperty} and called from a custom method 😎`\n   *     }\n   * })\n   * const hex = Hex(5, -1)\n   *\n   * hex.coordinates()    // { x: 5, y: -1 }\n   * // size is normalized to an object containing an x radius and y radius:\n   * hex.size             // { xRadius: 50, yRadius: 50 }\n   * hex.customProperty   // I'm custom 😃\n   * hex.customMethod()   // I'm custom 😃 and called from a custom method 😎\n   *\n   * // every hex created with Hex() shares these properties:\n   * const hex2 = Hex(3, 0)\n   * hex2.size            // { xRadius: 50, yRadius: 50 }\n   * hex2.customProperty  // I'm custom 😃\n   *\n   * // to set properties on individual hexes, pass them to Hex():\n   * const hex3 = Hex(-2, -1, { instanceProperty: `I'm a unique snowflake 😌` })\n   * hex3.instanceProperty    // I'm a unique snowflake 😌\n   */\n  return function extendHex(prototype = {}) {\n    const cartesianToCube = methods.cartesianToCubeFactory({ Point })\n    const defaultPrototype = {\n      /**\n       * Used internally for type checking\n       *\n       * @memberof Hex#\n       * @private\n       */\n      __isHoneycombHex: true,\n      /**\n       * Either ⬢ pointy or ⬣ flat. Defaults to `pointy`.\n       *\n       * @memberof Hex#\n       * @type {string}\n       * @default 'pointy'\n       */\n      orientation: 'pointy',\n      /**\n       * Distance from a hex's top left corner (as if it were a rectange). Defaults to `Point(0)`.\n       * Can be anything the {@link Honeycomb.Point} factory accepts.\n       * When a {@link Hex#toPoint|hex is converted to a point}, it is converted to this origin.\n       *\n       * @memberof Hex#\n       * @type {point}\n       * @default 0\n       */\n      origin: 0,\n      /**\n       * A hex's size that can be set as:\n       * * an object with `width` and `height`, representing the total width and height of the hex\n       * * an object with `xRadius` and `yRadius`. This can be visualized as if the hex was enclosed in an ellipse.\n       *   `xRadius` would be the distance from the center to the left or right of the ellipse (semi-major axis) and\n       *   `yRadius` would be the distance from the center to the top or bottom of the ellipse (semi-minor axis).\n       * * a number, represening the length of each side and the distance from the center to any corner of the hex\n       *   (which are the same in regular hexagons).\n       *\n       * ![Different ways to set size](docs/hex-sizes.png)\n       *\n       * When setting size with a number the hex will be regular. When setting size with an object it's possible to\n       * \"stretch\" a hex; having a (very) different width and height.\n       *\n       * Defaults to `{ xRadius: 1, yRadius: 1 }`.\n       *\n       * @memberof Hex#\n       * @type {{width: number, height: number}|{xRadius: number, yRadius: number}|number}\n       * @default { xRadius: 1, yRadius: 1 }\n       */\n      size: { xRadius: 1, yRadius: 1 },\n      /**\n       * Used to calculate the coordinates of rows for pointy hexes and columns for flat hexes.\n       * Defaults to `-1` (odd offset).\n       * See {@link OFFSET} for details.\n       * See {@link https://www.redblobgames.com/grids/hexagons/#coordinates-offset|redblobgames.com} why this is needed.\n       *\n       * @memberof Hex#\n       * @type {number}\n       * @default -1\n       * @see OFFSET\n       */\n      offset: -1,\n      /**\n       * Getter for `q` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get q() {\n        return this.cartesianToCube(this).q\n      },\n      /**\n       * Getter for `r` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get r() {\n        return this.cartesianToCube(this).r\n      },\n      /**\n       * Getter for `s` cube coordinate. Calls {@link Hex#cartesianToCube} internally.\n       *\n       * @memberof Hex#\n       * @type {number}\n       */\n      get s() {\n        return this.cartesianToCube(this).s\n      },\n\n      // methods:\n      add: methods.addFactory({ Hex, Point }),\n      /**\n       * Alias for {@link Hex#coordinates}.\n       * @memberof Hex#\n       * @instance\n       */\n      cartesian: methods.coordinates,\n      cartesianToCube,\n      center: methods.centerFactory({ Point }),\n      coordinates: methods.coordinates,\n      corners: methods.cornersFactory({ Point }),\n      cube: methods.cube,\n      cubeToCartesian: methods.cubeToCartesian,\n      distance: methods.distance,\n      equals: methods.equalsFactory({ Point }),\n      fromPoint: methods.fromPointFactory({ Point, Hex }),\n      height: methods.height,\n      isFlat: methods.isFlat,\n      isPointy: methods.isPointy,\n      lerp: methods.lerpFactory({ Hex }),\n      nudge: methods.nudgeFactory({ Hex }),\n      round: methods.roundFactory({ Hex }),\n      set: methods.setFactory({ Hex }),\n      subtract: methods.subtractFactory({ Hex, Point }),\n      /**\n       * Alias for {@link Hex#cubeToCartesian}.\n       * @memberof Hex#\n       * @instance\n       */\n      toCartesian: methods.cubeToCartesian,\n      /**\n       * Alias for {@link Hex#cartesianToCube}.\n       * @memberof Hex#\n       * @instance\n       */\n      toCube: cartesianToCube,\n      toPoint: methods.toPointFactory({ Point }),\n      toString: methods.toString,\n      width: methods.width,\n    }\n    const finalPrototype = Object.assign(defaultPrototype, prototype)\n\n    finalPrototype.size = normalizeRadiuses(finalPrototype.size, finalPrototype.isPointy())\n    // ensure origin is a point\n    finalPrototype.origin = Point(finalPrototype.origin)\n\n    // the toJSON method is added here, because only here it has (easy) access to the prototype\n    Object.assign(Hex, staticMethods, { toJSON: () => prototype })\n\n    /**\n     * @function Hex\n     *\n     * @description\n     * Factory function to create hexes. Use {@link Honeycomb.extendHex} to create a Hex factory.\n     *\n     * @see {@link redblobgames.com|https://www.redblobgames.com/grids/hexagons/#coordinates}\n     *\n     * @param {(number|Object|number[])} [xOrProps=]    The x coordinate,\n     *                                                  **or** an object containing *any* of the cartesian (`x` and `y`) coordinates and optional custom properties,\n     *                                                  **or** an object containing *all* of the cube (`q`, `r`, and `s`) coordinates and optional custom properties,\n     *                                                  **or** an array containing *any* of the cartesian (x and y) coordinates.\n     * @param {number} [xOrProps.x=]                    The x coordinate.\n     * @param {number} [xOrProps.y=]                    The y coordinate.\n     * @param {number} [y=]                             The y coordinate.\n     * @param {object} [customProps={}]                 Any custom properties. The coordinates are merged into this object, ignoring any coordinates present in `customProps`.\n     *\n     * @returns {hex}                                   A hex. It *always* contains *only* the cartesian (x and y) coordinates and any custom properties.\n     *\n     * @example\n     * const Hex = Honeycomb.extendHex()\n     *\n     * // passing numbers:\n     * Hex()                        // { x: 0, y: 0 }\n     * Hex(1)                       // { x: 1, y: 1 }\n     * Hex(1, 2)                    // { x: 1, y: 2 }\n     *\n     * // passing an object with cartesian coordinates:\n     * Hex({})                      // { x: 0, y: 0 }\n     * Hex({ x: 1 })                // { x: 1, y: 1 }\n     * Hex({ y: 2 })                // { x: 2, y: 2 }\n     * Hex({ x: 1, y: 2 })          // { x: 1, y: 2 }\n     *\n     * // passing an object with cube coordinates:\n     * Hex({ q: 1, r: 2, s: -3 })   // { x: 2, y: 2 }\n     * Hex({ q: 1 })                // throws an error because of missing cube coordinates\n     *\n     * // passing an array:\n     * Hex([])                      // { x: 0, y: 0 }\n     * Hex([1])                     // { x: 1, y: 1 }\n     * Hex([1, 2])                  // { x: 1, y: 2 }\n     *\n     * // custom properties:\n     * Hex(1, 2, { a: 3 })          // { a: 3, x: 1, y: 2 }\n     * Hex({ x: 1, y: 2, a: 3 })    // { a: 3, x: 1, y: 2 }\n     *\n     * // cloning a hex:\n     * const someHex = Hex(4, -2)   // { x: 4, y: -2 }\n     * const clone = Hex(someHex)   // { x: 4, y: -2 }\n     * someHex === clone            // false\n     */\n    function Hex(xOrProps, y, customProps = {}) {\n      let x\n\n      if (isObject(xOrProps)) {\n        let { q, r, s, ...rest } = xOrProps\n\n        if (isNumber(q) || isNumber(r) || isNumber(s)) {\n          const sum = q + r + s\n          // when any coordinate is undefined, sum will be NaN\n          // deal with floating point errors by allowing a maximum precision of 1e-12\n          if (Number.isNaN(sum) || sum > 1e-12) {\n            throw new Error(`Cube coordinates must have a sum of 0. q: ${q}, r: ${r}, s: ${s}, sum: ${q + r + s}.`)\n          }\n\n          ;({ x, y } = finalPrototype.cubeToCartesian({ q, r, s }))\n        } else {\n          ;({ x, y } = xOrProps)\n        }\n\n        customProps = rest\n      } else if (isArray(xOrProps)) {\n        ;[x, y] = xOrProps\n        // ignore all arguments except xOrProps\n        customProps = {}\n      } else {\n        x = xOrProps\n      }\n\n      /**\n       * An object with x and y properties and several methods in its prototype chain, created by a {@link Hex} factory.\n       *\n       * @typedef {Object} hex\n       * @property {number} x Cartesian x coordinate.\n       * @property {number} y Cartesian y coordinate.\n       */\n      return Object.assign(\n        // the prototype has to be attached here, else Grid's shape methods break 🙁\n        Object.create(finalPrototype),\n        Object.assign(customProps, ensureXY(x, y)),\n      )\n    }\n\n    return Hex\n  }\n}\n","/**\n * Calculates the third cube coordinate from the other two. The sum of all three coordinates must be 0.\n *\n * @memberof Hex\n * @static\n *\n * @param {number} firstCoordinate  The first other cube coordinate.\n * @param {number} secondCoordinate The second other cube coordinate.\n *\n * @returns {number}                The third cube coordinate.\n *\n * @example\n * const Hex = Honeycomb.extendHex()\n * Hex.thirdCoordinate(3, -2)   // -1\n */\nexport function thirdCoordinate(firstCoordinate, secondCoordinate) {\n  return -firstCoordinate - secondCoordinate\n}\n","import defineGridFactory from './grid'\nimport Grid from './grid/class'\nimport extendHexFactory from './hex'\nimport PointFactory from './point'\nimport { ensureXY, normalizeRadiuses } from './utils'\n\nconst Point = PointFactory({ ensureXY })\nconst extendHex = extendHexFactory({ ensureXY, normalizeRadiuses, Point })\nconst defineGrid = defineGridFactory({ extendHex, Grid, Point })\n\n/**\n * @namespace {Object} Honeycomb\n */\nexport { extendHex, defineGrid, Point }\n","import { isArray, isNumber } from 'axis.js'\nimport { compassToNumberDirection, signedModulo } from '../utils'\nimport * as methods from './prototype'\nimport * as statics from './statics'\n\nexport default function defineGridFactory({ extendHex, Grid, Point }) {\n  const { isValidHex } = Grid\n\n  /**\n   * @function defineGrid\n   *\n   * @memberof Honeycomb\n   * @static\n   *\n   * @description\n   * This function can be used to create {@link Grid} factories by passing it a {@link Hex} factory.\n   *\n   * @param {Hex} [Hex=Honeycomb.extendHex()] A {@link Hex} factory.\n   *                                          If nothing is passed, the default Hex factory is used by calling `Honeycomb.extendHex()` internally.\n   *\n   * @returns {Grid}                          A Grid factory.\n   *\n   * @example\n   * // create a Grid factory that uses the default Hex Factory:\n   * const Grid = Honeycomb.defineGrid()\n   * const hex = Grid.Hex()\n   * hex.size         // { xRadius: 1, yRadius: 1 }\n   *\n   * // create your own Hex factory\n   * const CustomHex = Honeycomb.extendHex({ size: 10, custom: '🤓' })\n   * // …and pass it to defineGrid() to create a Grid factory that produces your custom hexes\n   * const CustomGrid = Honeycomb.defineGrid(CustomHex)\n   * const customHex = CustomGrid.Hex()\n   * customHex.size   // { xRadius: 10, yRadius: 10 }\n   * customHex.custom // 🤓\n   */\n  return function defineGrid(Hex = extendHex()) {\n    // static properties\n    Object.assign(GridFactory, {\n      /**\n       * The {@link Hex} factory the Grid factory was created with.\n       * @memberof Grid\n       * @static\n       * @function\n       */\n      // don't manually bind `this` to Hex (i.e. `Hex.call`/`Hex.apply`) anywhere in the source\n      // it could cause this:\n      // function methodThatBindsThis() {\n      //     return Hex.call(this, ...) <- `this` refers to `GridFactory`\n      // }\n      // which is caused by the following line:\n      Hex,\n\n      // methods\n      /**\n       * @memberof Grid\n       * @static\n       * @method\n       *\n       * @param {*} value     Any value.\n       * @returns {boolean}   Whether the passed value is a valid hex.\n       */\n      isValidHex,\n      pointToHex: statics.pointToHexFactory({ Point, Hex }),\n      parallelogram: statics.parallelogramFactory({ Grid, Hex }),\n      triangle: statics.triangleFactory({ Grid, Hex }),\n      hexagon: statics.hexagonFactory({ Grid, Hex }),\n      rectangle: statics.rectangleFactory({ Grid, Hex, compassToNumberDirection, signedModulo }),\n      ring: statics.ringFactory({ Grid, Hex }),\n      spiral: statics.spiralFactory({ Grid, Hex }),\n    })\n\n    // prototype properties\n    Object.assign(Grid.prototype, {\n      // methods\n      get: methods.get,\n      hexesBetween: methods.hexesBetween,\n      hexesInRange: methods.hexesInRangeFactory({ isValidHex }),\n      neighborsOf: methods.neighborsOfFactory({\n        isValidHex,\n        signedModulo,\n        compassToNumberDirection,\n      }),\n      pointHeight: methods.pointHeight,\n      pointWidth: methods.pointWidth,\n      set: methods.setFactory({ isValidHex }),\n    })\n\n    /**\n     * @function Grid\n     *\n     * @description\n     * A function to create hex {@link grid}s and perform various operations on them.\n     *\n     * A Grid factory has several static methods that return {@link grid}s of hexes in a certain shape.\n     * It can also be called with 1 or more points/hexes or an array of points/hexes to create a {@link grid} instance.\n     *\n     * A {@link grid} extends `Array.prototype`, with some methods overwritten and some new methods added.\n     *\n     * @param {...point} [points] An array of points/hexes or separate arguments that are points/hexes.\n     * @returns {grid}            A grid instance containing only valid hexes.\n     *\n     * @example\n     * const Grid = Honeycomb.defineGrid()\n     * // the Hex factory used by the Grid to produce hexes is available as a property\n     * const Hex = Grid.Hex\n     *\n     * Grid(Hex(3, -1), Hex(2, 0))      // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     * Grid([Hex(3, -1), Hex(2, 0)])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     *\n     * // it also accepts points\n     * Grid({ x: 3, y: -1 }, [2, 0])    // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     * Grid([{ x: 3, y: -1 }, [2, 0]])  // [{ x: 3, y: -1 }, { x: 2, y: 0 }]\n     *\n     * // clone a grid:\n     * const grid = Grid(Hex(), Hex(1), Hex(2))\n     * const clonedGrid = Grid(grid)      // [{ x: 0, y: 0 }, { x: 1, y: 1 }, { x: 2, y: 2 }]\n     * grid === clonedGrid                // false\n     */\n    function GridFactory(...points) {\n      points = points.filter(Boolean)\n\n      if (isArray(points[0]) && (points[0].length === 0 || points[0].some(point => !isNumber(point)))) {\n        points = points[0]\n      }\n\n      /**\n       * @typedef {Object} grid\n       * @extends Array\n       *\n       * @property {number} length    Amount of hexes in the grid.\n       */\n      return new Grid(...points.map(point => Hex(point)))\n    }\n\n    return GridFactory\n  }\n}\n"],"names":["module","axis","types","split","type","Object","prototype","toString","call","this","slice","i","length","self","elem","factory","offsetFromZero","offset","distance","signedModulo","dividend","divisor","compassToNumberDirection","value","orientation","test","Error","toLowerCase","toUpperCase","includes","pointy","E","SE","SW","W","NW","NE","flat","S","N","ensureXY","x","y","isNumber","DIRECTION_COORDINATES","q","r","s","DIAGONAL_DIRECTION_COORDINATES","EPSILON","get","keyOrPoint","indexOf","setFactory","isValidHex","newHex","index","push","hexesBetween","firstHex","lastHex","step","Math","max","hexes","hex","nudge","lerp","round","hexesInRangeFactory","centerHex","range","includeCenterHex","min","cubeToCartesian","equals","filter","Boolean","neighborsOfFactory","directions","diagonal","coordinates","concat","map","direction","isString","pointWidth","mostLeft","mostRight","isPointy","sort","a","b","toPoint","width","pointHeight","mostUp","mostDown","height","pointToHexFactory","Hex","pointOrX","fromPoint","parallelogramFactory","Grid","start","onCreate","firstCoordinate","secondCoordinate","thirdCoordinate","grid","first","second","triangleFactory","size","DIRECTIONS","rStart","rEnd","hexagonFactory","radius","center","startR","endR","rectangleFactory","firstStop","secondStop","secondOffset","ringFactory","j","spiralFactory","ring","addFactory","Point","subtractFactory","multiplyFactory","divideFactory","PointFactory","add","methods","subtract","multiply","divide","isArray","isObject","assign","create","Array","__isHoneycombHex","fill","TypeError","point","fromIndex","Number","lastIndexOf","super","splice","deleteCount","unshift","cube","cartesianToCubeFactory","isFlat","xRadius","sqrt","yRadius","cornersFactory","origin","centerFactory","toPointFactory","fromPointFactory","equalsFactory","abs","roundFactory","roundedQ","roundedR","roundedS","diffQ","diffR","diffS","lerpFactory","t","nudgeFactory","staticMethods","extendHex","normalizeRadiuses","cartesianToCube","defaultPrototype","cartesian","corners","set","toCartesian","toCube","finalPrototype","xOrProps","customProps","rest","sum","isNaN","toJSON","extendHexFactory","defineGrid","GridFactory","points","some","pointToHex","statics","parallelogram","triangle","hexagon","rectangle","spiral","hexesInRange","neighborsOf","defineGridFactory"],"mappings":"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"}